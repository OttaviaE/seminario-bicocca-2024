y = "Proporzione risposte corrette",
title = "Item con monotonicità violata (descrittivo)"
) +
theme_minimal()
set.seed(123)
# --------------------------------------------------------
# 1. Simulo i dati
# --------------------------------------------------------
N <- 1500
# Latente solo per simulare l'item monotono
theta <- rnorm(N)
# Item monotono (logistico)
a <- 1.5
b <- 0
p_mono <- 1 / (1 + exp(-a * (theta - b)))
item_mono <- rbinom(N, 1, p_mono)
# Item non monotono (curva a campana)
p_non <- exp(-((theta - 0.5)^2) / 0.2)
item_non <- rbinom(N, 1, p_non)
# --------------------------------------------------------
# Score totale NON correlato = item casuali
# --------------------------------------------------------
J <- 8
items_random <- replicate(J, rbinom(N, 1, 0.5))
score_tot <- rowSums(items_random)
# --------------------------------------------------------
# 3. Proporzioni osservate per score totale
# --------------------------------------------------------
df <- data.frame(score = score_tot,
item_mono = item_mono,
item_non = item_non)
prop_mono <- aggregate(item_mono ~ score, df, mean)
prop_non  <- aggregate(item_non  ~ score, df, mean)
# --------------------------------------------------------
# 4. Grafici
# --------------------------------------------------------
library(ggplot2)
# Monotono
ggplot(prop_mono, aes(score, item_mono)) +
geom_point() + geom_line() +
labs(title="Item monotono", x="Score totale", y="Proporzione corrette") +
theme_minimal()
# NON monotono
ggplot(prop_non, aes(score, item_non)) +
geom_point() + geom_line() +
labs(title="Item NON monotono (finalmente!)",
x="Score totale", y="Proporzione corrette") +
theme_minimal()
set.seed(2025)
library(ggplot2)
library(dplyr)
# ------------------------------------------------
# 1) Simulazione
# ------------------------------------------------
N <- 2000
theta <- rnorm(N, 0, 1)
# Creo diversi item che dipendono da theta (questi costruiranno lo score totale)
J_score <- 8
a_vals <- runif(J_score, 0.8, 1.8)
b_vals <- rnorm(J_score, 0, 1)
items_for_score <- sapply(1:J_score, function(j) {
p <- plogis(a_vals[j] * (theta - b_vals[j]))   # ICC logistica
rbinom(N, 1, p)
})
colnames(items_for_score) <- paste0("it_score_", 1:J_score)
# Item monotono target (dipende direttamente da theta)
a_m <- 1.6; b_m <- 0.2
p_mono <- plogis(a_m * (theta - b_m))
item_mono <- rbinom(N, 1, p_mono)
# Item NON monotono target (funzione a campana attorno a theta = 0.5)
# normalizziamo la funzione per avere probabilità in [0,1]
p_non <- exp(-((theta - 0.5)^2) / (2 * 0.4^2))
# eventualmente scalare al massimo < 1
p_non <- p_non / max(p_non) * 0.98
item_non <- rbinom(N, 1, p_non)
# Dataset
dat <- data.frame(items_for_score, item_mono = item_mono, item_non = item_non)
# ------------------------------------------------
# 2) Score totale — sommo gli item che dipendono da theta
#    (NON includo item_non; includo item_mono opzionalmente)
# ------------------------------------------------
# includo gli items_for_score + item_mono per rendere score più informativo
score_tot <- rowSums(dat %>% select(starts_with("it_score_"), item_mono))
dat$score_tot <- score_tot
# ------------------------------------------------
# 3) Calcolo proporzioni osservate per ogni livello di score
#    (attenzione: alcuni livelli possono avere pochi soggetti)
# ------------------------------------------------
prop_df <- dat %>%
group_by(score_tot) %>%
summarise(
n = n(),
prop_mono = mean(item_mono),
prop_non  = mean(item_non)
) %>%
ungroup()
# Se vuoi ridurre rumore: raggruppa livelli di score con pochi casi (opzionale)
# qui esempio: raggruppo in quantili per smoothing (sostituisci i plot seguenti se preferisci)
dat$score_bin_q <- ntile(dat$score_tot, 12)  # 12 gruppi quantili
prop_q <- dat %>%
group_by(score_bin_q) %>%
summarise(
n = n(),
mean_score = mean(score_tot),
prop_mono = mean(item_mono),
prop_non  = mean(item_non)
)
# ------------------------------------------------
# 4) Grafici
# ------------------------------------------------
# A: grafico per ogni livello di score_tot (più dettagliato, più rumore possibile)
p1 <- ggplot(prop_df, aes(x = score_tot, y = prop_mono, size = n)) +
geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
scale_size_continuous(range = c(1,6)) +
labs(title = "Proporzione osservata per item MONOTONO\n(Score totale correlato con theta)",
x = "Score totale",
y = "Proporzione risposte corrette",
subtitle = "punti dimensionati per numerosità del livello di score") +
theme_minimal()
p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
scale_size_continuous(range = c(1,6)) +
labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
x = "Score totale",
y = "Proporzione risposte corrette",
subtitle = "punti dimensionati per numerosità del livello di score") +
theme_minimal()
# B: grafico smoothed per quantili (più stabile, usabile per presentazione)
p1q <- ggplot(prop_q, aes(x = mean_score, y = prop_mono)) +
geom_point() + geom_line() +
labs(title = "Item monotono — proporzioni per bin (quantili dello score)",
x = "Media score nel bin",
y = "Proporzione corrette") + theme_minimal()
p2q <- ggplot(prop_q, aes(x = mean_score, y = prop_non)) +
geom_point() + geom_line() +
labs(title = "Item NON monotono — proporzioni per bin (quantili dello score)",
x = "Media score nel bin",
y = "Proporzione corrette") + theme_minimal()
# Stampa
print(p1); print(p2)
print(p1q); print(p2q)
p2
p1
head(prop_q)
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q[,-ncol(prop_q)]
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q
head(new_prop)
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q[,-ncol(prop_q)]
new_prop1 = prop_q[, -(ncol(prop_q)-1)]
head(new_prop)
head(new_prop1)
new_prop$type = "Item Monotoni"
new_prop1$type = "Item Non Monotoni"
new_prop1 = prop_q[, -(ncol(prop_q)-1)]
colnames(new_prop1)[ncol(new_prop1)] = colnames(new_prop)[ncol(new_prop)]
head(new_prop1)
head(new_prop)
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q[,-ncol(prop_q)]
new_prop$type = "Item Monotoni"
new_prop1 = prop_q[, -(ncol(prop_q)-1)]
new_prop1
new_prop
#   theme_minimal()
#
# p2 <- ggplot(prop_df, aes(x = score_tot, y = prop_non, size = n)) +
#   geom_point(alpha = 0.8) + geom_line(aes(group = 1)) +
#   scale_size_continuous(range = c(1,6)) +
#   labs(title = "Proporzione osservata per item NON MONOTONO\n(Score totale correlato con theta)",
#        x = "Score totale",
#        y = "Proporzione risposte corrette",
#        subtitle = "punti dimensionati per numerosità del livello di score") +
#   theme_minimal()
new_prop = prop_q[,-ncol(prop_q)]
new_prop1 = prop_q[, -(ncol(prop_q)-1)]
colnames(new_prop1)[ncol(new_prop1)] = colnames(new_prop)[ncol(new_prop)]
new_prop1$type = "Item Non Monotoni"
new_prop$type = "Item Monotoni"
new_prop
new_prop1
myprop = rbind(new_prop, new_prop1)
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) + geom_point()+ geom_line()
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) +
geom_point(size = 2)+ geom_line(linewidth=1.2)
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) +
geom_point(size = 2)+ geom_line(linewidth=1.2) + theme_light()
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) +
geom_point(size = 2)+ geom_line(linewidth=1.2) + theme_light()+
ylab("Item Probability") + xlab("Scoe totale") +
theme(axis.text = element_text(size = 20),
axis.title = element_text(size = 22),
legend.title = element_blank(),
legend.text = element_text(size = 20))
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) +
geom_point(size = 2)+ geom_line(linewidth=1.2) + theme_light()+
ylab("Item Probability") + xlab("Scoe totale") +
theme(axis.text = element_text(size = 20),
axis.title = element_text(size = 22),
legend.title = element_blank(),
legend.text = element_text(size = 20),
legend.position.inside = c(.2,.8))
ggplot(myprop,
aes(x = mean_score, y = prop_mono,
linetype = type, color = type, group = type)) +
geom_point(size = 2)+ geom_line(linewidth=1.2) + theme_light()+
ylab("Item Probability") + xlab("Scoe totale") +
theme(axis.text = element_text(size = 20),
axis.title = element_text(size = 22),
legend.title = element_blank(),
legend.text = element_text(size = 20),
legend.position = c(.2,.8))
# ------------------------------------------------------------
# 1. SIMULAZIONE: UNIDIMENSIONALITÀ vs MULTIDIMENSIONALITÀ
# ------------------------------------------------------------
set.seed(123)
N  <- 1000   # numero partecipanti
J  <- 12     # numero item
# --------------------------
# UNIDIMENSIONALITÀ
# --------------------------
theta_uni <- rnorm(N)
# parametri item (discriminazioni e difficoltà)
a_uni <- runif(J, 1.0, 2.0)
b_uni <- rnorm(J, 0, 1)
# risposte simulate logistic-IRT
resp_uni <- sapply(1:J, function(j) {
p <- plogis(a_uni[j] * (theta_uni - b_uni[j]))
rbinom(N, 1, p)
})
colnames(resp_uni) <- paste0("Item_", 1:J)
# --------------------------
# MULTIDIMENSIONALITÀ (2 fattori)
# --------------------------
# 6 item sul fattore 1, 6 item sul fattore 2
theta1 <- rnorm(N)
theta2 <- rnorm(N)
a1 <- runif(6, 1.0, 2.0)
a2 <- runif(6, 1.0, 2.0)
b1 <- rnorm(6, 0, 1)
b2 <- rnorm(6, 0, 1)
# risposte IRT 2D (ogni item carica su un solo fattore)
resp_multi_part1 <- sapply(1:6, function(j) {
p <- plogis(a1[j] * (theta1 - b1[j]))
rbinom(N, 1, p)
})
resp_multi_part2 <- sapply(1:6, function(j) {
p <- plogis(a2[j] * (theta2 - b2[j]))
rbinom(N, 1, p)
})
resp_multi <- cbind(resp_multi_part1, resp_multi_part2)
colnames(resp_multi) <- paste0("Item_", 1:J)
# ------------------------------------------------------------
# Heatmap per UNIDIMENSIONALITÀ
# ------------------------------------------------------------
cor_uni <- cor(resp_uni)
df_uni <- melt(cor_uni)
ggplot(df_uni, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1,1)) +
labs(title = "Matrice di correlazione – Unidimensionalità",
x = "", y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(reshape2)
# ------------------------------------------------------------
# Heatmap per UNIDIMENSIONALITÀ
# ------------------------------------------------------------
cor_uni <- cor(resp_uni)
df_uni <- melt(cor_uni)
ggplot(df_uni, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1,1)) +
labs(title = "Matrice di correlazione – Unidimensionalità",
x = "", y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(df_uni, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1,1)) +
labs(x = "", y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# ------------------------------------------------------------
# Heatmap per MULTIDIMENSIONALITÀ
# ------------------------------------------------------------
cor_multi <- cor(resp_multi)
df_multi <- melt(cor_multi)
ggplot(df_multi, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1,1)) +
labs(title = "Matrice di correlazione – Multidimensionalità",
x = "", y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
pca_uni <- principal::principal(resp_uni, nfactors = J, rotate = "none")
screeplot(resp_uni)
resp_uni
screeplot(tetrachoric(resp_uni))
library(psych)
screeplot(tetrachoric(resp_uni))
screeplot(tetrachoric(resp_uni))
screeplot(cor_uni)
# ------------------------------------------------------------
# Heatmap per UNIDIMENSIONALITÀ
# ------------------------------------------------------------
cor_uni <- cor(resp_uni)
cor_uni
str(cor_uni)
?screeplot
fa.parallel(cor_uni)
?fa.parallel
fa.parallel(cor_uni, fa="fa")
fa.parallel(cor_multi, fa="fa")
x = rnorm(1000)
set.seed(666)
x = rnorm(1000)
y = rnorm(1000)
head(df_uni)
cor(x,y)
library(MASS)
set.seed(123)
# ------------------------------
# 1) INDIPENDENZA LOCALE
# ------------------------------
# residui indipendenti
res_ind <- matrix(rnorm(500 * 5), ncol = 5)
colnames(res_ind) <- paste0("Item", 1:5)
corr_ind <- cor(res_ind)
# riordino in formato lungo per ggplot
df_ind <- melt(corr_ind)
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1, 1)) +
labs(title = "Correlazioni residui – Indipendenza locale",
x = "", y = "") +
theme_minimal()
library(MASS)
set.seed(123)
# ------------------------------
# 1) INDIPENDENZA LOCALE
# ------------------------------
# residui indipendenti
res_ind <- matrix(rnorm(500 * 5), ncol = 5)
colnames(res_ind) <- paste0("Item", 1:5)
corr_ind <- cor(res_ind)
# riordino in formato lungo per ggplot
df_ind <- melt(corr_ind)
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1, 1)) +
labs(
x = "", y = "") +
theme_minimal()
Sigma <- matrix(0, 5, 5)
diag(Sigma) <- 1
Sigma[1,2] <- Sigma[2,1] <- 0.7  # dipendenza locale
# generazione residui con correlazione
res_dep <- mvrnorm(n = 500, mu = rep(0, 5), Sigma = Sigma)
colnames(res_dep) <- paste0("Item", 1:5)
corr_dep <- cor(res_dep)
# formato lungo
df_dep <- melt(corr_dep)
# heatmap
ggplot(df_dep, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(limits = c(-1, 1)) +
labs(
x = "", y = "") +
theme_minimal()
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +geom_tile() +
scale_fill_gradient2(
low = "darkblue",
mid = "white",
high = "darkred",
limits = c(-1, 1),
midpoint = 0
) +
labs(
x = "", y = "") +
theme_minimal()
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +geom_tile() +
scale_fill_gradient2(
low = "darkred",
mid = "white",
high = "darkblue",
limits = c(-1, 1),
midpoint = 0
) +
labs(
x = "", y = "") +
theme_minimal() +
theme(legend.position = "bottom",
axis.text = 20,
legend.text = 18,
legend.title = )
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +geom_tile() +
scale_fill_gradient2(
low = "darkred",
mid = "white",
high = "darkblue",
limits = c(-1, 1),
midpoint = 0
) +
labs(
x = "", y = "") +
theme_minimal() +
theme(legend.position = "bottom",
axis.text = element_text(size = 20),
legend.text = element_text(size = 18),
legend.title = )
# heatmap
ggplot(df_ind, aes(Var1, Var2, fill = value)) +
geom_tile() +geom_tile() +
scale_fill_gradient2(
low = "darkred",
mid = "white",
high = "darkblue",
limits = c(-1, 1),
midpoint = 0
) +
labs(
x = "", y = "") +
theme_minimal() +
theme(legend.position = "bottom",
axis.text = element_text(size = 20),
legend.text = element_text(size = 18),
legend.title = element_blank())
# heatmap
ggplot(df_dep, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(
low = "darkred",
mid = "white",
high = "darkblue",
limits = c(-1, 1),
midpoint = 0
) +
labs(
x = "", y = "") +
theme_minimal() +
theme(legend.position = "bottom",
axis.text = element_text(size = 20),
legend.text = element_text(size = 18),
legend.title = element_blank())
